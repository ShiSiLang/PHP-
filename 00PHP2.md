#第13章 文件系统

##13.1　文件处理

###13.1.1　打开/关闭文件
打开/关闭文件使用fopen()函数和fclose()函数。打开文件应格外认真，一不小心就有可能将文件内容全部删掉。

1．打开文件
对文件进行操作时首先要打开文件，这是进行数据存取的第一步。在PHP中使用fopen()函数打开文件，fopen()函数的语法如下：`resource fopen (string filename, string mode [, bool use_include_path]);`
其中，filename是要打开的包含路径的文件名，可以是相对路径，也可以是绝对路径，如果没有任何前缀则表示打开的是本地文件；mode是打开文件的方式，可取的值如表13.1所示；use_include_path是可选的，该参数在配置文件php.ini中指定一个路径，如E:\wamp\www\mess.php，如果希望服务器在这个路径下打开所指定的文件，可以设置为1或true。

Mode的取值列表
mode|名称|说明
---|---|---
r|只读|读模式--进行读取，文件指针位于文件开头
r+|只写|读写模式--进行读写，文件指针位于文件开头，在现有文件内容的末尾之前进行写入就会覆盖原有内容
W|只写|写模式--进行写入文件，文件指针指向头文件，如果该文件存在，则所有内容被删除，否则就会进行创建
w+|只写|写模式--进行读写，文件指针指向头文件，如果文件已经存在，则所有文件的内容被删除，否则会进行创建
x|谨慎写|写模式打开王文建，从文件头开始写，如果文件已经存在，则该文件将不会被打开，函数返回false，PHP将产生一个警告
x+|谨慎写|读写模式打开文件，从文件头开始写。如果文件已经存在，则该文件将不会被打开，函数返回false，PHP将产生一个警告
a|追加|追加模式打开文件，文件指针指向文件尾部。如果该文件已有内容，则将文件末尾开始追加，如果该文件不存在，则函数将创建这个文件
a+|追加|追加模式打开文件，文件指针指向头文件。如果该文件已有内容，则将文件末尾开始追加或者读取，如果该文件不存在，则函数将创建这个文件
b|二进制|二进制模式--用于与其它模式进行连接。如果王文建系统能够区分二进制文件和文本文件，可能会使用它。Windows可以区分；Unix则不区分。推荐使用这个选项，便于获取最大限度的可移植性。它是默认模式。
t|文本|用于与其它模式的结合，这个模式只是Windows下的一个选项


2．关闭文件
对文件的操作结束后应该关闭这个文件，否则可能引起错误。在PHP中使用fclose()函数关闭文件，该函数的语法如下：
`bool fclose(resource handle);`
该函数将参数handle指向的文件关闭，如果成功，返回true，否则返回false。其中的文件指针必须是有效的，并且是通过fopen()函数成功打开的文件。


13.1.2　读写文件
相对打开和关闭文件来说，读写文件更复杂一些。这里主要从读取数据和写入数据两方面讲解。

1．从文件中读取数据
从文件中读取数据，可以读取一个字符、一行字串或整个文件，还可以读取任意长度的字串。
1）读取整个文件：readfile()、file()和file_get_contents()
（1）readfile()函数
readfile()函数用于读入一个文件并将其写入到输出缓冲，如果出现错误则返回false。
函数语法如下：`int readfile(string filename)`
使用readfile()函数，不需要打开/关闭文件，不需要echo/print等输出语句，直接写出文件路径即可。
（2）file()函数
file()函数也可以读取整个文件的内容，只是file()函数将文件内容按行存放到数组中，包括换行符在内，如果失败则返回false。
函数语法如下：`array file(string filename)`
（3）file_get_contents()函数
该函数将文件内容（filename）读入一个字符串。如果有offset和maxlen参数，将在参数offset所指定的位置开始读取长度为maxlen的内容。如果失败，返回false。
函数语法如下：`string file_get_contents(string filename[,int offset[,int maxlen]])`
该函数适用于二进制对象，是将整个文件的内容读入到一个字符串中的首选方式。

2）读取一行数据：fgets()和fgetss()
（1）fgets()函数
fgets()函数用于一次读取一行数据。
函数语法如下：`string fgets(int handle [, int length])`
其中，handle是被打开的文件，length是要读取的数据长度。函数能够实现从handle指定文件中读取一行并返回长度最大值为length-1个字节的字符串。在遇到换行符、EOF或者读取了length-1个字节后停止。如果忽略length参数，那么读取数据直到行结束。
（2）fgetss()函数
fgetss()函数是fgets()函数的变体，用于读取一行数据，同时，fgetss()函数会过滤掉被读取内容中的HTML和PHP标记。
函数语法如下：`string fgetss (resource handle [, int length [, string allowable_tags]])`
该函数能够从读取的文件中过滤掉任何HTML和PHP标记。可以使用allowable_tags参数来控制哪些标记不被过滤掉。

3）读取一个字符：fgetc()
在对某一个字符进行查找、替换时，需要有针对性地对某个字符进行读取，在PHP中可以使用fgetc()函数实现此功能。
函数语法如下：`string fgetc (resource handle)`
该函数返回一个字符，该字符从handle指向的文件中得到。遇到EOF则返回false。

4）读取任意长度的字串：fread()
fread()可以从文件中读取指定长度的数据
函数语法如下：`string fread (int handle, int length)`
其中，handle为指向的文件资源，length是要读取的字节数。当函数读取length个字节或到达EOF时停止执行。


2．将数据写入文件
写入数据也是PHP中常用的文件操作，在PHP中使用fwrite()和file_put_contents()函数向文件中写入数据。fwrite()函数也称为fputs()，它们的用法相同。
fwrite()函数的语法如下：`int fwrite(resource handle, string string [, int length])`
该函数把内容string写入文件指针handle处。如果指定了长度length，则写入length个字节后停止。如果文件内容长度小于length，则会输出全部文件内容。

file_put_contents()函数是PHP 5新增的函数，
其语法为：`int file_put_contents (string filename, string data [, int flags])`
filename为写入数据的文件。data为要写入的数据。flags可以是FILE_USE_INCLUDE_PATH、FILE_APPEND或LOCK_EX，LOCK_EX为独占锁定，在13.3.3节锁定文件中将会介绍。
使用file_put_contents()函数和依次调用fopen()、fwrite()、fclose()函数的功能一样。下面通过实例比较一下该函数的优越性。


###13.1.3　操作文件
除了可以对文件内容进行读写，对文件本身同样也可以进行操作，如复制、重命名、查看修改日期等。
PHP内置了大量的文件操作函数，常用的文件函数如表
函数原型|函数说明|举例
---|---|---
bool copy(string path1,string path2)|将文件从path1复制到path2，如果成功，返回true，失败返回false。|copy('tm.txt', '../tm.txt')
bool rename(string filename1, string filename2)|将filename2重命名为filename2|rename('1.txt', '2.txt')
bool unlink(string filename)|删除文件，成功返回true，失败返回false|unlink('./tm.txt')
int fileatime(string filename)|返回文件最后一次被访问的时间，时间以UNIX时间戳的方式返回|fileatime('1.txt')
int filesize(string filename)|取得文件filename的大小(bytes)|filesize('1.txt')
int filemtime(string filename)|返回文件最后一次被修改的时间，时间以UNIX时间戳的方式返回|filemtime('1.txt')
array pathinfo(string name[,int options])|返回一个数组，包含name的路径信息。有dirname，basename和extension。可以通过option设置要返回的信息。有PATHINFO_DIRNAME,PATHINFO_BASENAME, PATHINF_EXTENSION，默认返回全部|$arr=pathinfo('1.txt')
string realpath(string filename)|返回文件filename的绝对路径|realpath('1.txt')
array stat(string filename)|返回一个数组，包括文件的相关信息，如文件大小，最后修改时间|$arr=stat('1.txt')


##13.2　目录处理

###13.2.1　打开/关闭目录
1．打开目录
PHP使用opendir()函数来打开目录，函数语法如下：`resource opendir (string path)`
函数opendir()的参数path是一个合法的目录路径，成功执行后返回目录的指针。如果path不是一个合法的目录或者因为权限或文件系统错误而不能打开目录，则返回false并产生一个E_WARNING级别的错误信息。可以在opendir()前面加上“@”符号来抑制错误信息的输出。

2．关闭目录
PHP使用closedir()函数关闭目录，函数语法如下：`void closedir (resource handle)`
参数handle为使用opendir()函数打开的一个目录指针。

is_dir()函数判断当前路径是否为一个合法的目录。如果合法，返回true，否则返回false。


###13.2.2　浏览目录
在PHP中浏览目录中的文件使用的是scandir()函数
函数语法如下：`array scandir (string directory [, int sorting_order])`
该函数返回一个数组，包含directory中的所有文件和目录。参数sorting_order指定排序顺序，默认按字母升序排序，如果添加了该参数，则变为降序排序。


###13.2.3　操作目录
目录是特殊的文件，也就是说，对文件的操作处理函数（如重命名）多数同样适用于目录。

目录操作函数
函数原型|函数说明|举例
bool mkdir(string pathname)|新建一个指定目录|makdir('temp')
bool rmdir(string pathname)|删除指定目录，该目录必须为空|rmdir('tmp')
string getcwwd(void)|取得当前工作的目录|getcwd()
bool chdir(string directory)|改变当前目录为directory|chdir('../')
float disk_free_space(string directory)|返回目录中的可用空间(bytes)。被检查的文件必须通过服务器的文件系统访问| disk_free_space('E:\\wamp')
float disk_total_space(string directory)|返回目录的总空间大小| disk_total_space('E:\\wamp')
string readdir(resource handle)|返回目录中下一个文件的文件名(使用该函数时，目录必须使用opendir()函数打开的）。在PHP5之前，都是使用这个函数来浏览目录的|readdir()
void rewinddir(resource handle)|将指定的目录重新指定到目录的开头|rewinddir($handle)


##13.3　文件处理的高级应用

###13.3.1　远程文件的访问
PHP支持URL格式的文件调用，只要在php.ini文件中配置一下即可。在PHP中找到allow_url_fopen，将该选项设为ON，重启服务器后即可使用HTTP或FTP的URL格式。
如：`fopen('http://127.0.0.1/tm/sl/index.php','rb');`

###13.3.2　文件指针
PHP可以实现文件指针的定位及查询，从而实现所需信息的快速查询。文件指针函数有rewind()、fseek()、feof()和ftell()。

1．rewind()函数
该函数将文件handle的指针设为文件流的开头
语法如下：`bool rewind ( resource handle )`
如果将文件以附加模式（“a”）打开，写入文件的任何数据总是会被附加在后面，不论文件指针的位置在何处。

2．fseek()函数
fseek()函数实现文件指针的定位
语法如下：`int fseek ( resource handle, int offset [, int whence] )`
handle为要打开的文件。offset为指针位置或相对whence的偏移量，可以是负值。
whence的值包括以下3种：
* SEEK_SET，位置等于offset字节。
* SEEK_CUR，位置等于当前位置加上offset字节。
* SEEK_END，位置等于文件尾加上offset字节。
如果忽略whence，系统默认为SEEK_SET。

3．feof()函数
该函数判断文件指针是否在文件尾，语法如下：`bool feof ( resource handle )`
如果文件指针到了文件结束的位置，就返回true，否则返回false。

4．ftell()函数
ftell()函数返回当前指针的位置，语法如下：`int ftell ( resource handle )`


###13.3.3　锁定文件
在向一个文本文件写入内容时，需要先锁定该文件，以防止其他用户同时修改此文件内容。在PHP中锁定文件的函数为flock()，语法如下：`bool flock ( int handle, int operation)`
handle为一个已经打开的文件指针，operation的参数值如表
参数值|说明
---|---
LOCK_SH|取得共享锁定(读写程序)
LOCK_EX|取得独占锁定(写入程序)
LOCK_UN|释放锁定
LOCK_NB|防止flock()在锁定是堵塞


##13.4　文件上传

###13.4.1　配置php.ini文件
要想顺利地实现上传功能，首先要在php.ini文件中开启文件上传，并对其中的一些参数作出合理的设置。找到File Uploads项，可以看到下面有3个属性值，表示含义如下。
* file_uploads：如果值是on，说明服务器支持文件上传；如果为off，则不支持。
* upload_tmp_dir：上传文件临时目录。在文件被成功上传之前，文件首先存放到服务器端的临时目录中。如果想要指定位置，可在这里设置，否则使用系统默认目录即可。
* upload_max_filesize：服务器允许上传的文件的最大值，以MB为单位。系统默认为2MB，用户可以自行设置。
除了File Uploads项，还有几个属性也会影响到上传文件的功能。
* max_execution_time：PHP中一个指令所能执行的最大时间，单位是秒。
* memory_limit：PHP中一个指令所分配的内存空间，单位是MB。
如果使用集成化的安装包来配置PHP的开发环境，上述介绍的这些配置信息默认已经配置好了。
如果要上传超大的文件，需要对php.ini文件进行修改。包括upload_max_filesize的最大值，max_execution_time一个指令所能执行的最大时间和memory_limit一个指令所分配的内存空间。

###13.4.2　预定义变量$_FILES
$_FILES变量存储的是上传文件的相关信息，这些信息对于上传功能有很大的作用。该变量是一个二维数组。
保存的信息如表
元素名|说明
---|---
$_FILES[filename][name]|存储上传文件的文件名
$_FILES[filename][size]|存储了文件大小，单位为字节
$_FILES[filename][temp_name]|文件上传时，首先在临时目录中能够保存一个临时文件，该变量为临时文件名
$_FILES[filename][type]|上传文件的类型
$_FILES[filename][error]|存储了上传文件的结果，0表示上传成功


###13.4.3　文件上传函数
PHP中使用move_uploaded_file()函数上传文件。
该函数的语法如下:`bool move_uploaded_file(string filename,string destination)`
move_uploaded_file()函数将上传文件存储到指定的位置。如果成功，则返回true，否则返回false。参数filename是上传文件的临时文件名，即$_FILES[tmp_name]；参数destination是上传后保存的新的路径和名称。

使用move_uploaded_file()函数上传文件时，在创建form表单时，必须设置form表单的“enctype="multipart/form-data"”属性。

###13.4.4　多文件上传
PHP支持同时上传多个文件，只需要在表单中对文件上传域使用数组命名即可。


##13.5　小结

##13.6　实践与练习


---

#第14章 面向对象

##14.1　面向对象的基本概念

这里所指的面向对象，准确地说应该叫作面向对象编程（OOP），是面向对象的一部分。面向对象包括3个部分：面向对象分析（Object Oriented Analysis，OOA）、面向对象设计（Object Oriented Design，OOD），以及面向对象编程（Object Oriented Programming，OOP）。面向对象编程的两个重点概念是类和对象。

###14.1.1　类
类是属性和方法的集合，是面向对象编程方式的核心和基础，通过类可以将零散的用于实现某项功能的代码进行有效管理。


###14.1.2　对象
类只是具备某项功能的抽象模型，实际应用中还需要对类进行实例化，这样就引入了对象的概念。
对象是类进行实例化后的产物，是一个实体。

###14.1.3　面向对象编程的三大特点
面向对象编程的三大特点就是封装性、继承性和多态性。

1．封装性
封装性，也可以称为信息隐藏，就是将一个类的使用和实现分开，只保留有限的接口（方法）与外部联系。对于用到该类的开发人员，只要知道这个类该如何使用即可，而不用去关心这个类是如何实现的。这样做可以让开发人员更多地把精力集中起来专注别的事情，同时也避免了程序之间的相互依赖而带来不便。

2．继承性
继承性就是派生类（子类）自动继承一个或多个基类（父类）中的属性与方法，并可以重写或添加新的属性或方法。继承这个特性简化了对象和类的创建，增加了代码的可重用性。继承分单继承和多继承，PHP所支持的是单继承，也就是说，一个子类有且只有一个父类。

3．多态性
多态性是指同一个类的不同对象，使用同一个方法可以获得不同的结果，这种技术称为多态性。多态性增强了软件的灵活性和重用性。

##14.2　PHP与对象

###14.2.1　类的定义
和很多面向对象的语言一样，PHP也是通过class关键字加类名来定义类的。类的格式如下：
```
    <?php
      class SportObject{             //定义运动类
      …
      }
    ?>
```

###14.2.2　成员方法
类中的函数被称为成员方法。函数和成员方法唯一的区别就是，函数实现的是某个独立的功能，而成员方法是实现类中的一个行为，是类的一部分。


###14.2.3　类的实例化
类的方法已经添加，接下来就使用方法，但使用方法不像使用函数那么简单。首先要对类进行实例化，实例化是通过关键字new来声明一个对象。然后使用如下格式来调用要使用的方法：`对象名 -> 成员方法`
我们已经知道，类是一个抽象的描述，是功能相似的一组对象的集合。如果想用到类中的方法或变量，首先就要把它具体落实到一个实体，也就是对象上。


###14.2.4　成员变量
类中的变量，也称为成员变量（也有称为属性或字段的）。成员变量用来保存信息数据，或与成员方法进行交互来实现某项功能。
定义成员变量的格式为：`关键字 成员变量名`
关键字可以使用public、private、protected、static和final中的任意一个。
访问成员变量和访问成员方法是一样的。只要把成员方法换成成员变量即可，格式为：`对象名 -> 成员变量`


###14.2.5　类常量
既然有变量，当然也会有常量。常量就是不会改变的量，是一个恒值。圆周率是众所周知的一个常量。
定义常量使用关键字const，如：`const PI= 3.14159;`

可以发现，常量的输出和变量的输出是不一样的。常量不需要实例化对象，直接由“类名+常量名”调用即可。
常量输出的格式为：`类名::常量名`
类名和常量名之间的两个冒号“::”称为作用域操作符，使用这个操作符可以在不创建对象的情况下调用类中的常量、变量和方法。


###14.2.6　构造方法和析构方法
1．构造方法
构造方法是生成对象时自动执行的成员方法，作用就是初始化对象。该方法可以没有参数，也可以有多个参数。
构造方法的格式如下：`void __construct([mixed args [,…]])`
构造方法是初始化对象时使用的。如果类中没有构造方法，那么PHP会自动生成一个。自动生成的构造方法没有任何参数，没有任何操作。

2．析构方法
析构方法的作用和构造方法正好相反，是对象被销毁时被调用的，作用是释放内存。
析构方法的格式为：`void__destruct(void)`
PHP使用的是一种“垃圾回收”机制，自动清除不再使用的对象，释放内存。就是说即使不使用unset()函数，析构方法也会自动被调用，这里只是明确一下析构函数在何时被调用。一般情况下是不需要手动创建析构方法的。


###14.2.7　继承和多态的实现
1．继承
子类继承父类的所有成员变量和方法，包括构造函数，当子类被创建时，PHP会先在子类中查找构造方法。如果子类有自己的构造方法，PHP会先调用子类中的方法。当子类中没有时，PHP则去调用父类中的构造方法，这就是继承。
继承是通过关键字extends来声明的，继承的格式如下：`class subClass extends`

2．多台
多态好比有一个成员方法让大家去游泳，这个时候有的人带游泳圈，有的人拿浮板，还有的人什么也不带。虽是同一种方法，却产生了不同的形态，就是多态。

多态存在两种形式：覆盖和重载。
* 所谓覆盖就是在子类中重写父类的方法，而在两个子类的对象中虽然调用的是父类中相同的方法，但返回的结果是不同的。
* 重载，是类的多态的另一种实现。函数重载指一个标识符被用作多个函数名，且能够通过函数的参数个数或参数类型将这些同名的函数区分开来，调用不发生混淆。其好处是可实现代码重用，不用为了对不同的参数类型或参数个数而写多个函数。

多个函数使用同一个名字，但参数个数、参数数据类型不同。调用时，虽然方法名称相同，但根据参数个数或者参数数据类型不同自动调用对应的函数。


###14.2.8　“$this ->”和“::”的使用

1．“$this->”
如何调用成员方法有了基本的了解，那就是用对象名加方法名，格式为“对象名->方法名”。但在定义类时（如SportObject类），根本无法得知对象的名称是什么。这时如果想调用类中的方法，就要用伪变量“$this->”。$this的意思就是本身，所以“$this->”只可以在类的内部使用。

2．操作符“::”
相比伪变量$this只能在类的内部使用，操作符“::”更为强大。操作符“::”可以在没有声明任何实例的情况下访问类中的成员方法或成员变量。
使用“::”操作符的通用格式为：`关键字::变量名/常量名/方法名`
这里的关键字分为以下3种情况。
* parent：可以调用父类中的成员变量、成员方法和常量。
* self：可以调用当前类中的静态成员和常量。
* 类名：可以调用本类中的变量、常量和方法。


###14.2.9　数据隐藏
1．public（公共成员）
顾名思义，就是可以公开的、没有必要隐藏的数据信息。可以在程序中的任何位置（类内、类外）被其他的类和对象调用。子类可以继承和使用父类中所有的公共成员。

2．private（私有成员）
被private关键字修饰的变量和方法，只能在所属类的内部被调用和修改，不可以在类外被访问。在子类中也不可以。

3．protected（保护成员）
被protected修饰的类成员，可以在本类和子类中被调用，其他地方则不可以被调用。

private关键字可以将数据完全隐藏起来，除了在本类外，其他地方都不可以调用，子类也不可以。对于有些变量希望子类能够调用，但对另外的类来说，还要做到封装。这时，就可以使用protected。

`虽然PHP中没有对修饰变量的关键字做强制性的规定和要求，但从面向对象的特征和设计方面考虑，一般使用private或protected关键字来修饰变量，以防止变量在类外被直接修改和调用。`


###14.2.10　静态变量（方法）
不是所有的变量（方法）都要通过创建对象来调用。可以通过给变量（方法）加上static关键字来直接调用。调用静态成员的格式为：`关键字::静态成员`
关键字可以是：
* self，在类内部调用静态成员时所使用。
* 静态成员所在的类名，在类外调用类内部的静态成员时所用。
在静态方法中，只能调用静态变量，不能调用普通变量，而普通方法则可以调用静态变量。
使用静态成员，除了可以不需要实例化对象，另一个作用就是在对象被销毁后，仍然保存被修改的静态数据，以便下次继续使用。

`静态成员不用实例化对象，当类第一次被加载时就已经分配了内存空间，所以直接调用静态成员的速度要快一些。但如果静态成员声明得过多，空间一直被占用，反而会影响系统的功能。这个尺度只能通过实践积累，才能真正地掌握。`


##14.3　面向对象的高级应用

###14.3.1　final关键字
final，中文含义是“最终的”“最后的”。被final修饰过的类和方法就是“最终的版本”。
如果有一个类的格式为：`final class class_name{ … }`
说明该类不可以再被继承，也不能再有子类。

如果有一个方法的格式为：`final function method_name()`
说明该方法在子类中不可以进行重写，也不可以被覆盖。


###14.3.2　抽象类
抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。
抽象类使用abstract关键字来声明，格式为：`abstract class AbstractName{  …  }`
抽象类和普通类相似，包含成员变量、成员方法。两者的区别在于，抽象类至少要包含一个抽象方法。抽象方法没有方法体，其功能的实现只能在子类中完成。
抽象方法也是使用abstract关键字来修饰的，它的格式为：`abstract function abstractName();`
在抽象方法后面要有分号“；”。
`抽象类和抽象方法主要应用于复杂的层次关系中，这种层次关系要求每一个子类都包含并重写某些特定的方法。`


###14.3.3　接口的使用
继承特性简化了对象、类的创建，增加了代码的可重性。但PHP只支持单继承。如果想实现多重继承，就要使用接口。PHP可以实现多个接口。
接口类通过interface关键字来声明，并且类中只能包含未实现的方法和一些成员变量，格式如下：
```
    interface InterfaceName{
        function interfaceName1();
        function interfaceName2();
        …
    }
```
不要用public以外的关键字来修饰接口中的类成员，对于方法，不写关键字也可以。这是一个接口类自身的属性决定的。

子类是通过implements关键字来实现接口的，如果要实现多个接口，那么每个接口之间应使用逗号“，”连接。而且所有未实现的方法需要在子类中全部实现，否则PHP将会出现错误。
格式如下：
```
    class SubClass implements InterfaceName1, InterfaceName2{
        function interfaceName1(){
            …//功能实现
        }
        function interfaceName2(){
            …//功能实现
        }
        …
    }
```

通过上面的实例可以发现，抽象类和接口实现的功能十分相似。抽象类的优点是可以在抽象类中实现公共的方法，而接口则可以实现多继承。至于何时使用抽象类和接口就要看具体实现了。


###14.3.4　克隆对象

1．关键字clone
在PHP 4中，对象被当作普通的数据类型来使用。如果想引用对象，需要使用“&”来声明，否则会按照PHP 4的默认方式来按值传递对象。

在PHP 5中如果需要将对象复制，也就是克隆一个对象，需要使用关键字clone来实现。克隆对象的格式为：
    $object1 = new ClassName();
    $object2 = clone $object1;

2．__clone方法
有时除了单纯地克隆对象外，还需要克隆出来的对象可以拥有自己的属性和行为。这时就可以使用__clone方法来实现。__clone方法的作用是：在克隆对象的过程中，调用__clone方法，可以使克隆出来的对象保持自己的一些行为及属性。


###14.3.5　对象比较
两个等号“==”是比较两个对象的内容
3个等号“===”是比较对象的引用地址。


###14.3.6　对象类型检测
instanceof操作符可以检测当前对象属于哪个类。
一般格式为：`ObjectName instanceof ClassName`


###14.3.7　魔术方法
PHP中有很多以两个下划线开头的方法，如前面已经介绍过的__construct、__destruct和__clone，这些方法被称为魔术方法。本节中将会学习到其他一些魔术方法。

PHP中保留了所有以“__”开头的方法，所以只能使用在PHP文档中已有的这些方法，不要自己创建。

魔术方法均用public关键字修饰。

1．__set和__get方法
这两个魔术方法的作用分别为：
* 当程序试图写入一个不存在或不可见的成员变量时，PHP就会执行__set方法。__set方法包含两个参数，分别表示变量名称和变量值，两个参数不可省略。
* 当程序调用一个未定义或不可见的成员变量时，可以通过__get方法来读取变量值。__get方法有一个参数，表示要调用的变量名。
如果希望PHP调用这些魔术方法，首先必须在类中进行定义，否则PHP不会执行未创建的魔术方法。

2．__call方法
__call方法的作用是：当程序试图调用不存在或不可见的成员方法时，PHP会先调用__call方法来存储方法名及其参数。
__call方法包含两个参数，即方法名和方法参数。其中，方法参数是以数组形式存在的。

3．__sleep和__wakeup方法
使用serialize()函数可以实现序列化对象。就是将对象中的变量全部保存下来，对象中的类则只保存类名。在使用serialize()函数时，如果实例化的对象包含__sleep方法，则会先执行__sleep方法。该方法可以清除对象并返回一个该对象中所有变量的数组。使用__sleep方法的目的是关闭对象可能具有的数据库连接等类似的善后工作。

unserialize()函数可以重新还原一个被serialize()函数序列化的对象，__wakeup方法则是恢复在序列化中可能丢失的数据库连接及相关工作。

4．__toString方法
魔术方法__toString的作用是：当使用echo或print输出对象时，将对象转化为字符串。

注意点:
（1）如果没有__toString方法，直接输出对象将会发生致命错误（fatal error）。
（2）输出对象时应注意，echo或print后面直接跟要输出的对象，中间不要加多余的字符，否则__toString方法不会被执行，如“echo '字串'.$myComputer”“echo ' '.$myComputer”等都不可以，一定要注意。

5．__autoload方法
将一个独立、完整的类保存到一个PHP页中，并且文件名和类名保持一致，这是每个开发人员都需要养成的良好习惯。这样，在下次重复使用某个类时即能很轻易地找到它。但还有一个问题是让开发人员头疼不已的，如果要在一个页面中引进很多的类，需要使用include_once()函数或require_once()函数一个个地引入。

PHP 5解决了这个问题，__autoload方法可以自动实例化需要使用的类。当程序要用到一个类，但该类还没有被实例化时，PHP 5将使用__autoload方法，在指定的路径下自动查找和该类名称相同的文件。如果找到，程序则继续执行；否则，报告错误。


##14.4　面向对象的应用——中文字符串的截取类


##14.5　小结


##14.6　实践与练习


----


#第15章 PHP加密技术


##15.1　PHP加密函数
数据加密的基本原理就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为“密文”，通过这样的途径来达到保护数据不被非法窃取和阅读的目的。

在PHP中能对数据进行加密的函数主要有crypt()、md5()和sha1()，还有加密扩展库Mcrypt和Mash。这里主要介绍其中的3种：crypt()函数、md5()函数和sha1()函数。


###15.1.1　使用crypt()函数进行加密
crypt()函数可以完成单向加密功能
语法如下：`string crypt(string str[, string salt]);`
其中，str是需要加密的字符串，salt为加密时使用的干扰串。如果省略掉第二个参数，则会随机生成一个干扰串。

crypt()函数支持的4种算法和salt参数的长度
算法|salt长度
---|---
CCCRYPT_STD_DES|2-characters(默认)
CRYPT_EXT_DES|9-character
CCRYPT_MD5|12-character(以$1$开头)
CRYPT_BLOWWFISH|16-character(以$2$开头)

默认情况下，PHP使用一个或两个字符的DES干扰串，如果系统使用的是MD5，则会使用12个字符。可以通过CRYPT_SALT_LENGTH变量来查看当前所使用的干扰串的长度。

crypt()函数是单向加密的，密文不可还原成明码，而每次加密后的数据还不相同，这就是salt参数要解决的问题。crypt()函数用salt参数对明文进行加密，判断时，对输出的信息再次使用相同的salt参数进行加密，对比两次加密后的结果来进行判断。

###15.1.2　使用md5()函数进行加密
md5()函数使用MD5算法。MD5的全称是Message-Digest Algorithm 5（信息-摘要算法），它的作用是把不同长度的数据信息经过一系列的算法计算成一个128位的数值，就是把一个任意长度的字节串变换成一定长的大整数。注意这里是“字节串”而不是“字符串”，因为这种变换只与字节的值有关，与字符集或编码方式无关。
md5()函数的格式如下：`string md5 (string str [, bool raw_output]);`
其中，字符串str为要加密的明文，raw_output如果设为true，则函数返回一个二进制形式的密文，该参数默认为false。


###15.1.3　使用sha1()函数进行加密
和MD5类似的还有SHA算法。SHA全称为Secure Hash Algorithm（安全哈希算法），PHP提供的sha1()函数使用的就是SHA算法，
函数的语法如下：`string sha1 (`string str [, bool raw_output])`
函数返回一个40位的十六进制数，如果参数raw_output为true，则返回一个20位的二进制数。默认raw_output为false。


###15.2　PHP加密扩展库
PHP除了自带的几种加密函数外，还有功能更全面的加密扩展库Mcrypt和Mhash。其中Mcrypt扩展库可以实现加密和解密功能，既能将明文加密，也可以将密文还原。Mhash扩展库则包含了MD5在内的多种hash算法实现的混编函数。


###15.2.1　Mcrypt扩展库

1．Mcrypt库安装
单向加密的优势是密文无法还原为明文，即使数据被截获也不会造成资料外泄。但有时，还需要将密文还原成明文，这就需要使用双向加密技术了。Mcrypt是一个功能十分强大的加密算法扩展库。在标准的PHP安装过程中并没有安装Mcrypt，但PHP的主目录下包含了libmcrypt.dll和libmhash.dll文件（libmhash.dll是Mhash扩展库，这里一起安装上），首先将文件复制到系统目录windows\system32下，然后在php.ini文件中找到“;extension=php_mcrypt.dll”和“;extension=php_mhash.dll”这两个语句，将前面的分号“；”去掉，最后重新启动服务器，即可使用这两个扩展库。

2．Mcrypt库常量
Mcrypt库支持20多种加密算法和8种加密模式，读者可以通过mcrypt_list_algorithms()和mcrypt_list_modes()函数查看
这些算法和模式在实际应用中要用常量来表示，写的时候分别加上前缀MCRYPT_和MCRYPT_MODE_来表示，如：
 　TWOFISH算法表示为MCRYPT_TWOFISH。
 　CBC加密模式表示为MCRYPT_MODE_CBC。

3．Mcrypt应用

下面对代码中加粗的函数进行讲解。
（1）string mcrypt_create_iv ( int size [, int source] )
使用Mcrypt进行数据加密、解密之前，首先要创建一个初始化向量（简称iv）。创建初始化向量需要两个参数：size指定了iv的大小，source为iv的源。source可以取如下值。
 　MCRYPT_RAND：系统随机数。
 　MCRYPE_DEV_RANDOM：读取目录/dev/random中的数据（UNIX系统）。
 　MCRYPT_DEV_URANDOM：读取目录/dev/urandom中的数据（UNIX系统）。
（2）int mcrypt_get_iv_size ( string cipher, string mode )
该函数返回初始化向量（iv）的大小。函数中的两个参数是前面刚介绍过的加密算法（cipher）和算法模式（mode）。
（3）string mcrypt_encrypt (string cipher, string key, string data, string mode [, string iv])
初始化向量后，即可使用mcrypt_encrypt()加密函数对数据进行加密。该函数的5个参数分别如下。
 　cipher：加密算法。例15.6中为变量$cipher，这里的加密算法可以和初始化向量中的加密算法不一样。
 　key：密钥。例15.6中的变量$key。
 　data：需要加密的数据。例15.6中的变量$str。
 　mode：算法模式。例15.6中的变量$modes，可以和初始化向量中的模式不一样。
 　iv：初始化向量。例15.6中的变量$iv。
（4）string mcrypt_decrypt (string cipher, string key, string data, string mode [, string iv])
解密函数mcrypt_decrypt()和加密函数mcrypt_encrypt()的参数几乎是一样的。唯一不同的是参数data，这里的data为需要解密的数据，而不是原始数据。在例15.6中为需要解密的变量$str_encrypt。

加密函数和解密函数中的cipher、key和mode参数必须一致，否则数据不会被还原。
Mcrypt扩展库包含30多个函数，对加密技术感兴趣的读者可以参考PHP手册，其中有详细的介绍。


###15.2.2　Mhash扩展库

1．Mhash库安装
关于Mhash库的安装在前面已经介绍过，这里不再重复。读者可以参见15.2.1节中的Mcrypt库安装。

2．Mhash库常量
Mhash库支持MD5、SHA、CRC32等多种散列算法，可以使用mhash_count()和mhash_get_hash_name()函数输出支持的算法名称。

3．Mhash应用
相比Mcrypt扩展库的30多个函数，Mhash库中只有5个函数，除了上面使用到的两个函数外，下面来介绍其他的3个函数。
 　mhash_get_block_size()函数
函数语法：`int mhash_get_block_size ( int hash )`
该函数用来获取参数hash的区块大小，如mhash_get_block_size(MHASH_CRC32)。

 　mhash()函数
函数语法：`string mhash ( int hash, string data [, string key] )`
该函数返回一个哈希值。其中，hash为要使用的算法，data是要加密的数据，key是加密使用的密钥。

 　mhash_keygen_s2k()函
函数语法：`string mhash_keygen_s2k ( int hash, string password, string salt, int bytes )`
该函数将根据参数password和salt返回一个长度为字节的key值，参数hash为要使用的算法。其中salt为一个固定8字节的值，如果用户给出的数值小于8字节，将用0补齐。


##15.3　小结


##15.4　实践与练习


---

#第18章 PHP操作MySQL数据库

##18.1　PHP操作MySQL数据库的方法

###18.1.1　连接MySQL服务器
PHP操作MySQL数据库，首先要建立与MySQL数据库的连接，MySQLi扩展提供了mysqli_connect()函数实现与MySQL数据库的连接，
函数语法如下：`mysqli mysqli_connect ([string server [, string username [, string password [, string dbname [, int port [, string socket]]]]]])`
mysqli_connect()函数用于打开一个到MySQL服务器的连接，如果成功则返回一个MySQL连接标识，失败则返回false。

该函数的参数如表
参数|说明
---|---
server|mysql服务器地址
username|用户名
password|密码，默认为空
dbname|连接的数据库名称
port|mysql服务器使用的端口
socket|Unix域socket

`为了屏蔽由于数据库连接失败而显示的不友好的错误信息，可以在mysqli_connect()函数前加“@”，该符号用来屏蔽错误提示。`


###18.1.2　选择MySQL数据库
应用mysqli_connect()函数可以创建与MySQL服务器的连接，同时也可以指定要选择的数据库名称。
例如，在连接MySQL服务器的同时选择名称为db_database18的数据库，代码如下：
`$connID = mysqli_connect("127.0.0.1", "root", "111", "db_database18");`

除此之外，MySQLi扩展还提供了mysqli_select_db()函数用来选择MySQL数据库。
其语法如下：`bool mysqli_select_db (mysqli link, string dbname)`
* link为必选参数，应用mysqli_connect()函数成功连接MySQL数据库服务器后返回的连接标识。
* dbname为必选参数，用户指定要选择的数据库名称。

`在实际的程序开发过程中，将MySQL服务器的连接和数据库的选择存储于一个单独文件中，在需要使用的脚本中通过require语句包含这个文件即可。这样做既有利于程序的维护，同时也避免了代码的冗余。在本章后面的章节中，将MySQL服务器的连接和数据库的选择存储在根目录下的conn文件夹下，文件名称为conn.php。`


###18.1.3　执行SQL语句
要对数据库中的表进行操作，通常使用mysqli_query()函数执行SQL语句。
其语法如下：`mixed mysqli_query(mysqli link, string query [, int resultmode])`
 　link为必选参数，mysqli_connect()函数成功连接MySQL数据库服务器后所返回的连接标识。
 　query为必选参数，所要执行的查询语句。
 　resultmode为可选参数，该参数取值有MYSQLI_USE_RESULT和MYSQLI_STORE_RESULT。其中，MYSQLI_STORE_RESULT为该函数的默认值。如果返回大量数据，可以应用MYSQLI_USE_RESULT，但应用该值时，以后的查询调用可能返回一个commands out of sync错误，解决办法是应用mysqli_free_result()函数释放内存。

`如果SQL语句是查询指令select，成功则返回查询结果集，否则返回false；如果SQL语句是insert、delete、update等操作指令，成功则返回true，否则返回false。`

下面看一下如何通过mysqli_query()函数执行简单的SQL语句。
例如，执行一个添加会员记录的SQL语句的代码如下：
`$result=mysqli_query($conn,"insert into tb_member values('mrsoft','123','mrsoft@mrsoft.com')");`
例如，执行一个修改会员记录的SQL语句的代码如下：
`$result=mysqli_query($conn,"update tb_member set user='mrbook',pwd='111' where user='mrsoft'");`
例如，执行一个删除会员记录的SQL语句的代码如下：
`$result=mysqli_query($conn,"delete from tb_member where user='mrbook'");`
例如，执行一个查询会员记录的SQL语句的代码如下：
`$result=mysqli_query($conn,"select ＊ from tb_member");`

`mysqli_query()函数不仅可以执行诸如select、update和insert等SQL指令，而且可以选择数据库和设置数据库编码格式。`
选择数据库的功能与mysqli_select_db()函数是相同的，代码如下：
`mysqli_query($conn,"use db_database18");`
设置数据库编码格式的代码如下：
`mysqli_query($conn,"set names utf8");`



###18.1.4　将结果集返回到数组中
使用mysqli_query()函数执行select语句，如果成功将返回查询结果集。下面介绍一个对查询结果集进行操作的函数mysqli_fetch_array()。它将结果集返回到数组中。其语法如下：
`array mysqli_fetch_array ( resource result [, int result_type] )`
* result：资源类型的参数，要传入的是由mysqli_query()函数返回的数据指针。
* result_type：可选项，设置结果集数组的表述方式。有以下3种取值：
* MYSQLI_ASSOC：返回一个关联数组。数组下标由表的字段名组成。
* MYSQLI_NUM：返回一个索引数组。数组下标由数字组成。
* MYSQLI_BOTH：返回一个同时包含关联和数字索引的数组。默认值是MYSQLI_BOTH。
mysqli_fetch_array()函数返回的字段名区分大小写，这是初学者最容易忽略的问题。


###18.1.5　从结果集中获取一行作为对象
mysqli_fetch_object()函数。
语法格式如下：`mixed mysqli_fetch_object (resource result)`
mysqli_fetch_object()函数和mysqli_fetch_array()函数类似，只有一点区别：它返回的是一个对象而不是数组，即该函数只能通过字段名来访问数组。
访问结果集中行的元素的语法结构如下：`$row->col_name`          
mysqli_fetch_object()函数返回的字段名同样是区分大小写的。


###18.1.6　从结果集中获取一行作为枚举数组
mysqli_fetch_row()函数从结果集中取得一行作为枚举数组。
其语法如下：`mixed mysqli_fetch_row (resource result)`
mysqli_fetch_row()函数返回根据所取得的行生成的数组，如果没有更多行则返回null。返回数组的偏移量从0开始，即以$row[0]的形式访问第一个元素（只有一个元素时也是如此）。


###18.1.7　从结果集中获取一行作为关联数组
mysqli_fetch_assoc()函数从结果集中取得一行作为关联数组。
其语法如下：`mixed mysqli_fetch_assoc (resource result)`
mysqli_fetch_assoc()函数返回根据所取得的行生成的数组，如果没有更多行则返回null。该数组的下标为数据表中字段的名称。


###18.1.8　获取查询结果集中的记录数
使用mysqli_num_rows()函数，可以获取由select语句查询到的结果集中行的数目。
mysqli_num_rows()函数的语法如下：`int mysqli_num_rows (resource result)`
mysqli_num_rows()函数返回结果集中行的数目。此命令仅对select语句有效。要取得被insert、update或者delete语句所影响到的行的数目，要使用mysqli_affected_rows()函数。


###18.1.9　释放内存
mysqli_free_result()函数用于释放内存，数据库操作完成后，需要关闭结果集，以释放系统资源，
该函数的语法格式如下：`void mysqli_free_result(resource result);`
mysqli_free_result()函数将释放所有与结果标识符result所关联的内存。该函数仅需要在考虑到返回很大的结果集时会占用多少内存时调用。在脚本结束后所有关联的内存都会被自动释放。


###18.1.10　关闭连接
完成对数据库的操作后，需要及时断开与数据库的连接并释放内存，否则会浪费大量的内存空间，在访问量较大的Web项目中，很可能导致服务器崩溃。在MySQL函数库中，使用mysqli_close()函数断开与MySQL服务器的连接，
该函数的语法格式如下：`bool mysqli_close (mysqli link)`
参数link为mysqli_connect()函数成功连接MySQL数据库服务器后所返回的连接标识。如果成功则返回true，失败则返回false。


`PHP中与数据库的连接是非持久连接，系统会自动回收，一般不用设置关闭。但如果一次性返回的结果集比较大，或网站访问量比较多，则最好使用mysqli_close()函数手动进行释放。`


###18.1.11　连接与关闭MySQL服务器的最佳时机
MySQL服务器连接应该及时关闭，但并不是说每一次数据库操作后都要立即关闭MySQL连接。


##18.2　管理MySQL数据库中的数据

###18.2.1　添加数据

###18.2.2　编辑数据

###18.2.3　删除数据
删除数据库中的数据应用的是delete语句，如果在不指定删除条件的情况下，那么将删除指定数据表中的所有数据，如果定义了删除条件，那么将删除数据表中指定的记录。删除操作的执行是一件非常慎重的事情，因为一旦执行该操作，数据就没有恢复的可能。


###18.2.4　批量数据操作


##18.3　小结


##18.4　实践与练习


---

#第19章 PDO数据库抽象层

##19.1　什么是PDO

###19.1.1　PDO概述
PDO是PHP Date Object（PHP数据对象）的简称，它是与PHP 5.1版本一起发行的，目前支持的数据库包括Firebird、FreeTDS、Interbase、MySQL、MS SQL Server、ODBC、Oracle、Postgre SQL、SQLite和Sybase。有了PDO，就不必再使用mysql_*函数、oci_*函数或者mssql_*函数，也不必再为它们封装数据库操作类，只需要使用PDO接口中的方法就可以对数据库进行操作。在选择不同的数据库时，只需修改PDO的DSN（数据源名称）。

在PHP 6中将默认使用PDO连接数据库，所有非PDO扩展将会在PHP 6中被移除。该扩展提供PHP内置类PDO来对数据库进行访问，不同数据库使用相同的方法名，解决数据库连接不统一的问题。

###19.1.2　PDO特点
PDO是一个“数据库访问抽象层”，作用是统一各种数据库的访问接口，与MySQL和MS SQL函数库相比，PDO让跨数据库的使用更具有亲和力；与ADODB和MDB2相比，PDO更高效。

PDO将通过一种轻型、清晰、方便的函数，统一各种不同RDBMS库的共有特性，实现PHP脚本最大限度的抽象性和兼容性。

PDO吸取现有数据库扩展成功和失败的经验教训，利用PHP 5的最新特性，可以轻松地与各种数据库进行交互。

PDO扩展是模块化的，能够在运行时为数据库后端加载驱动程序，而不必重新编译或重新安装整个PHP程序。例如，PDO_MySQL扩展会替代PDO扩展实现MySQL数据库API。还有一些用于Oracle、PostgreSQL、ODBC和Firebird的驱动程序，更多的驱动程序尚在开发。

###19.1.3　安装PDO
PDO是与PHP 5.1一起发行的，默认包含在PHP 5.1中。由于PDO需要PHP 5核心面向对象特性的支持，因此其无法在PHP 5之前的版本中使用。

默认情况下，PDO在PHP 5.2中为开启状态，但是要启用对某个数据库驱动程序的支持，仍需要进行相应的配置操作。

在Linux环境下，要使用MySQL数据库，可以在configure命令中添加如下选项：
`--with-pdo-mysql=/path/to/mysql/installation`

在Windows环境下，PDO在php.ini文件中进行配置，要启用PDO，首先必须加载“extension=php_pdo.dll”，如果想让其支持某个具体的数据库，那么还要加载对应的数据库选项。例如，要支持MySQL数据库，则需要加载“extension=php_pdo_mysql.dll”选项。

在完成数据库的加载后，要保存php.ini文件，并且重新启动Apache服务器，修改才能够生效。


##19.2　PDO连接数据库

###19.2.1　PDO构造函数
在PDO中，要建立与数据库的连接需要实例化PDO的构造函数。PDO构造函数的语法如下：
`__construct(string $dsn[,string $username[,string $password[,array $driver_options]]])`
构造函数的参数说明如下。
* dsn：数据源名，包括主机名端口号和数据库名称。
* username：连接数据库的用户名。
* password：连接数据库的密码。
* driver_options：连接数据库的其他选项。


###19.2.2　DSN详解
DSN是Data Source Name（数据源名称）的缩写。DSN提供连接数据库需要的信息。PDO的DSN包括3部分：PDO驱动名称（如mysql、sqlite或者pgsql）；冒号和驱动特定的语法。每种数据库都有其特定的驱动语法。

在使用不同的数据库时，必须明确数据库服务器是完全独立于PHP的实体。虽然笔者在讲解本书的内容时，数据库服务器和Web服务器是在同一台计算机上，但是实际的情况可能不是如此。数据库服务器可能与Web服务器不是在同一台计算机上，此时要通过PDO连接数据库，就需要修改DSN中的主机名称。

由于数据库服务器只在特定的端口上监听连接请求，每种数据库服务器具有一个默认的端口号（MySQL是3306），但是数据库管理员可以对端口号进行修改，所以PHP有可能找不到数据库的端口，此时就可以在DSN中包含端口号。

另外，由于一个数据库服务器中可能拥有多个数据库，所以在通过DSN连接数据库时，通常都包括数据库名称，这样可以确保连接的是想要的数据库，而不是其他人的数据库。


##19.3　PDO中执行SQL语句

###19.3.1　exec方法
exec方法返回执行后受影响的行数，其语法如下：`int PDO::exec ( string statement )`
其中，statement是要执行的SQL语句。该方法返回执行查询时受影响的行数，通常用于insert、delete和update语句中。

###19.3.2　query方法
query方法通常用于返回执行查询后的结果集，其语法如下：`PDOStatement PDO::query ( string statement )`
其中，statement是要执行的SQL语句。它返回的是一个PDOStatement对象。

###19.3.3　预处理语句——prepare和execute
预处理语句包括prepare和execute两个方法。首先通过prepare方法做查询的准备工作，然后通过execute方法执行查询，并且还可以通过bindParam方法来绑定参数提供给execute方法。Prepare和execute方法的语法如下：
`PDOStatement PDO::prepare ( string statement [, array driver_options] )`

`bool PDOStatement::execute ( [array input_parameters] )`


##19.4　PDO中获取结果集
在PDO中获取结果集有3种方法：fetch、fetchAll和fetchColumn。


###19.4.1　fetch方法
fetch方法获取结果集中的下一行，
其语法格式如下：`mixed PDOStatement::fetch ( [int fetch_style [, int cursor_orientation [, int cursor_offset]]] )`

fetch_style为控制结果集的返回方式，其可选方式如表
值|说明
---|---
PDO::FETCH_ASSOC|关联数组西宁市
PDO::FETCH_NUM|数字索引数组形式
PDO::FETCH_BOTH|两者数组形式都有，这是默认的
PDO::FETCH_OBJ|按照对象的形式，类似于之前的mysql_fetch_object()
PDO::FETCH_BOUND|以布尔值的形式返回结果，同时将获取的列值赋值给bindParam方法指定的变量
PDO::FETCH_LAZY|以关联数组、数字索引数组和对象3中形式返回

* 参数cursor_orientation：PDOStatement对象的一个滚动游标，可用于获取指定的一行。
* 参数cursor_offset：游标的偏移量。

###19.4.2　fetchAll方法
fetchAll方法获取结果集中的所有行
其语法如下：`array PDOStatement::fetchAll ([int fetch_style [, int column_index]])`
* fetch_style：控制结果集中数据的显示方式。
* column_index：字段的索引。
其返回值是一个包含结果集中所有数据的二维数组。

###19.4.3　fetchColumn方法
fetchColumn方法获取结果集中下一行指定列的值
其语法如下：`string PDOStatement::fetchColumn ( [int column_number] )`
可选参数column_number设置行中列的索引值，该值从0开始。如果省略该参数，则将从第一列开始取值。
通过fecthColumn方法获取结果集中下一行中指定列的值，注意这里是“结果集中下一行中指定列的值”。


##19.5　PDO中捕获SQL语句中的错误
在PDO中捕获SQL语句中的错误有3种方案可以选择。

###19.5.1　使用默认模式——PDO::ERRMODE_SILENT
在默认模式中设置PDOStatement对象的errorCode属性，但不进行其他任何操作。
通过prepare和execute方法向数据库中添加数据，设置PDOStatement对象的errorCode属性，手动检测代码中的错误。

###19.5.2　使用警告模式——PDO::ERRMODE_WARNING
警告模式会产生一个PHP警告，并设置errorCode属性。如果设置的是警告模式，那么除非明确地检查错误代码，否则程序将继续按照其方式运行。

设置警告模式，通过prepare和execute方法读取数据库中数据，并且通过while语句和fetch方法完成数据的循环输出，体会在设置成警告模式后执行错误的SQL语句。

###19.5.3　使用异常模式——PDO::ERRMODE_EXCEPTION
异常模式会创建一个PDOException，并设置errorCode属性。它可以将执行代码封装到一个try{…}catch{…}语句块中。未捕获的异常将会导致脚本中断，并使用堆栈跟踪显示哪里出现的问题。



##19.6　PDO中错误处理
在PDO中有两个获取程序中错误信息的方法：errorCode方法和errorInfo方法。


###19.6.1　errorCode方法
errorCode方法用于获取在操作数据库句柄时所发生的错误代码，这些错误代码被称为SQLSTATE代码。
其语法格式如下：`int PDOStatement::errorCode ( void )`
errorCode方法返回一个SQLSTATE，SQLSTATE是由5个数字和字母组成的代码。

###19.6.2　errorInfo方法
errorInfo方法用于获取操作数据库句柄时所发生的错误信息。
其语法格式如下：`array PDOStatement::errorInfo ( void )`
errorInfo方法的返回值为一个数组，它包含了相关的错误信息。


##19.7　PDO中事务处理
在PDO中同样可以实现事务处理的功能，其应用的方法如下：
* 开启事务——beginTransaction方法
beginTransaction方法将关闭自动提交（autocommit）模式，直到事务提交或者回滚以后才恢复。
* 提交事务——commit方法
commit方法完成事务的提交操作，成功则返回true，否则返回false。
* 事务回滚——rollback方法
rollback方法执行事务的回滚操作。
通过prepare和execute方法向数据库中添加数据，并且通过事务处理机制确保数据能够正确地添加到数据中。


##19.8　PDO中存储过程
存储过程允许在更接近于数据的位置操作数据，从而减少带宽的使用，它们使数据独立于脚本逻辑，允许使用不同语言的多个系统以相同的方式访问数据，从而节省花费在编码和调试上的宝贵时间。同时它使用预定义的方案执行操作，提高查询速度，并且能够阻止与数据的直接相互作用，从而起到保护数据的作用。


##19.9　小结


##19.10　实践与练习


---

#第20章 ThinkPHP框架


##20.1　ThinkPHP简介
ThinkPHP可以更方便和快捷地开发和部署应用，其不仅仅是企业级应用，任何PHP应用开发都可以从ThinkPHP的简单和快速的特性中受益。ThinkPHP本身具有很多的原创特性，并且倡导“大道至简，开发由我”的开发理念，用最少的代码完成更多的功能，宗旨就是让Web应用开发更简单、更快速。

ThinkPHP遵循Apache 2开源许可协议发布，意味着可以免费使用ThinkPHP，甚至允许把基于ThinkPHP开发的应用开源或商业产品发布/销售。

###20.1.1　ThinkPHP框架的特点
ThinkPHP是一个性能卓越并且功能丰富的轻量级PHP开发框架，其宗旨就是让Web应用开发更简单、更快速。ThinkPHP值得推荐的特性包括：
* 类库导入：ThinkPHP是首先采用基于类库包和命名空间的方式导入类库，让类库导入看起来更加简单清晰，而且还支持冲突检测和别名导入。为了方便项目的跨平台移植，系统还可以严格检查加载文件的大小写。
* URL模式：系统支持普通模式、PATHINFO模式、REWRITE模式和兼容模式的URL方式，支持不同的服务器和运行模式的部署，配合URL路由功能，可以随心所欲地构建需要的URL地址和进行SEO优化工作。
* 编译机制：独创的核心编译和项目的动态编译机制，有效减少OOP开发中文件加载的性能开销。
* 查询语言：内建丰富的查询机制，包括组合查询、复合查询、区间查询、统计查询、定位查询、动态查询和原生查询，让数据查询简洁高效。
* 视图模型：轻松、动态地创建数据库视图，多表查询不再烦恼。
* 分组模块：不用担心大项目的分工协调和部署问题，分组模块解决跨项目的难题。
* 模板引擎：系统内建了一款卓越的基于XML的编译型模板引擎，支持两种类型的模板标签，融合了Smarty和JSP标签库的思想，支持标签库扩展。通过驱动还可以支持Smarty、EaseTemplate、TemplateLite、Smart等第三方模板引擎。
* Ajax支持：内置Ajax数据返回方法，支持JSON、XML和EVAL格式返回客户端，并且系统不绑定任何Ajax类库，可随意使用自己熟悉的Ajax类库进行操作。
* 缓存机制：系统支持包括文件方式、APC、Db、Memcache、Shmop、Eaccelerator和Xcache在内的多种动态数据缓存类型，以及可定制的静态缓存规则，并提供了快捷方法进行存取操作。


###20.1.2　环境要求
ThinkPHP可以支持Windows/UNIX服务器环境，可运行于包括Apache、IIS在内的多种Web服务器。需要PHP 5及以上版本支持。支持MySQL、MSSQL、PgSQL、Sqlite、Oracle等数据库。

###20.1.3　下载ThinkPHP框架

ThinkPHP是一个免费、开源、快捷、简单的OOP轻量级PHP开发框架，它遵循Apache 2开源协议发布，是为了敏捷的企业级开发而诞生的。获取ThinkPHP的方式有很多。
 　官方网站：http://thinkphp.cn。
 　完整版本：http://thinkphp.googlecode.com/svn/trunk。
 　核心版本：http://thinkphp.googlecode.com/svn/trunk/ThinkPHP。

本章将以ThinkPHP 3.0为例来讲解ThinkPHP框架的使用。

1．什么是MVC
MVC是一种经典的程序设计理念，此模式将应用程序分为3个部分：模型层（Model）、视图层（View）、控制层（Controller），MVC是这3个部分英文字母的缩写。
* 模型层（Model）：模型层是应用程序的核心部分，它可以是一个实体对象或一种业务逻辑，它之所以称为模型，是因为它在应用程序中有更好的重用性和扩展性。
* 视图层（View）：视图层提供应用程序与用户之间的交互界面，在MVC理论之中，这一层并不包含任何的业务逻辑，仅提供一种与用户交互的视图。
* 控制层（Controller）：控制层用于对程序中的请求进行控制，作用就像国家的宏观调控，它可以选择调用哪些视图或者调用哪些模型。

2．什么是CURD
CURD是数据库操作的缩写词，也是几种数据库操作技术的缩写，C代表创建（Create），U代表更新（Update），R代表读取（Read），D代表删除（Delete）。CURD定义了用于处理数据的基本操作。之所以将CURD提升到一个技术难题的高度，是因为完成一个涉及在多个数据库系统中进行CURD操作的汇总相关的活动，其性能可能会随数据关系的变化而有非常大的差异。

CURD在具体的应用中并非一定使用create、update、read和delete字样的方法，但是它们完成的功能是一致的。例如，ThinkPHP就是使用add、save、select和delete方法表示模型的CURD操作。

3．什么是单一入口
单一入口通常是指一个项目或者应用具有一个统一（但并不一定是唯一）的入口文件，也就是说项目的所有功能操作都是通过这个入口文件进行的，并且往往入口文件是第一步被执行的。

单一入口的好处是项目整体比较规范，因为同一个入口，往往其不同操作之间具有相同的规则。另外一个方面就是单一入口控制较为灵活，因为拦截方便，类似如一些权限控制、用户登录方面的判断和操作可以统一处理。


##20.2　ThinkPHP架构
ThinkPHP遵循简洁实用的设计原则，兼顾开发速度和执行速度的同时，也注重易用性。本节内容将对ThinkPHP框架的整体思想和架构体系进行详细说明。


###20.2.1　ThinkPHP的目录结构
ThinkPHP框架中的目录分为两部分：系统目录和项目目录。
系统目录是下载的ThinkPHP框架类库本身的，系统目录如下：
目录名称|主要作用
---|---
Common|包含框架的一些公共文件、系统定义和惯例配置等
Lang|目录语言文件夹，目前ThinkPHP支持的语言也有简体中文、繁体中文和英文
Lib|系统的基类库目录
Tpl|系统能够的模板目录
Mode|框架模式扩展目录
Vendor|第三方类库目录

项目目录是用户实际应用的目录，如下所示：
目录名称|主要作用
---|---
index.php|项目入口文件
Common|项目公共目录，放置项目公共函数
Lang|项目语言包目录
Conf|项目配置目录，放置配置文件
Lib|项目基目录，通常包括Action和Model目录
Tpl|项目模板目录
Runtime|项目运行目录，包括Cache、Temp、Data和Log


###20.2.2　自动生成目录


###20.2.3　项目目录部署方案
方案一：
20-----------------项目名称
-Admin-------------后台管理项目目录
-Home--------------项目目录
--Common-----------项目公共目录，放置项目公共函数
--Conf-------------项目配置目录，放置配置文件
--Lang-------------项目语言包目录(可选)
--Lib--------------项目基目录，通常包括Action和Model目录
--Runtime----------项目运行目录，包括Cache、Temp、Data和Log
--Tpl--------------项目模板目录
-ThinkPHP----------系统目录
-admin.php---------网站的后台入口文件
-index.php---------网站的入口文件

方案二：
20-----------------项目名称
-APP---------------APP项目目录
--Common-----------项目公共目录，放置项目公共函数
--Conf-------------项目配置目录，放置配置文件
--Lang-------------项目语言包目录(可选)
--Lib--------------项目基目录，通常包括Action和Model目录
--Runtime----------项目运行目录，包括Cache、Temp、Data和Log
--Tpl--------------项目模板目录
-Public------------网站公共目录
--Css--------------CSS样式文件
--Image------------图片文件件
--Js---------------JS脚本文件
-ThinkPHP----------系统目录
-index.php---------网站的入口文件

这样部署的好处是系统目录和项目目录可以存储于非Web访问目录下面，网站目录下面只需放置Public公共目录和index.php入口文件（如果是多个项目，每个项目的入口文件都需要放到Web目录下面），从而提高网站的安全性。

###20.2.4　命名规范
ThinkPHP框架有其自身的一定规范，要应用ThinkPHP框架开发项目，那么就要尽量遵守它的规范。下面介绍一下ThinkPHP的命名规范。
* 类文件都是以.class.php为后缀（这里指的是ThinkPHP内部使用的类库文件，不代表外部加载的类库文件），使用驼峰法命名，并且首字母大写，例如DbMysql.class.php。
* 函数、配置文件等其他类库文件之外的一般是以.php为后缀（第三方引入的不做要求）。
* 确保文件的命名和调用大小写一致，是由于在类UNIX系统上面，对大小写是敏感的（而ThinkPHP在调试模式下，即使在Windows平台也会严格检查大小写）。
* 类名和文件名一致（包括上面说的大小写一致），例如UserAction类的文件命名是UserAction.class.php，InfoModel类的文件名是InfoModel.class.php。
* 函数的命名使用小写字母和下划线的方式，例如get_client_ip。
* Action控制器类以Action为后缀，例如UserAction、InfoAction。
* 模型类以Model为后缀，例如UserModel、InfoModel。
* 方法的命名使用驼峰法，并且首字母小写，例如getUserName。
* 属性的命名使用驼峰法，并且首字母小写，例如tableName。
* 以双下划线“__”打头的函数或方法作为魔法方法，例如__call和__autoload。
* 常量以大写字母和下划线命名，例如HAS_ONE和MANY_TO_MANY。
* 配置参数以大写字母和下划线命名，例如HTML_CACHE_ON。
* 语言变量以大写字母和下划线命名，例如MY_LANG；以下划线开头的语言变量通常用于系统语言变量，例如_CLASS_NOT_EXIST_。
* 数据表和字段采用小写加下划线方式命名，例如think_user和user_name。

在ThinkPHP中，有一个函数命名的特例，就是单字母大写函数，这类函数通常是某些操作的快捷定义，或者有特殊的作用，例如ADSL方法等，它们有着特殊的含义。另外，ThinkPHP默认使用UTF-8编码，所以请确保程序文件采用UTF-8编码格式保存，并且去掉BOM信息头（去掉BOM信息头有很多方式，不同的编辑器都有设置方法，也可以用工具进行统一检测和处理）。


###20.2.5　项目构建流程
ThinkPHP具有项目目录自动创建功能，因此构建项目应用程序非常简单，您只需定义好项目的入口文件，在第一次访问入口文件时，系统会自动根据在入口文件中所定义的目录路径，迅速创建好项目的相关目录结构。在完成项目目录结构的创建后，看接下来都需要进行哪些工作。


##20.3　ThinkPHP的配置
配置文件是ThinkPHP框架程序得以运行的基础条件，框架的很多功能都需要在配置文件中配置之后才可以生效，包括URL路由功能、页面伪静态和静态化等。ThinkPHP提供了灵活的全局配置功能，采用最有效率的PHP返回数组方式定义，支持惯例配置、项目配置、调试配置和模块配置，并且会自动生成配置缓存文件，无须重复解析。

ThinkPHP在项目配置上创造了自己独有的分层配置模式

系统的配置参数是通过静态变量全局存取的，存取方式非常简单高效。

###20.3.1　配置格式
ThinkPHP框架中所有配置文件的定义格式均采用返回PHP数组的方式
配置参数不区分大小写（因为无论使用大小写定义，都会转换成小写），但是习惯上保持大写定义的原则。另外，还可以在配置文件中使用二维数组来配置更多的信息。
系统目前最多支持二维数组的配置级别，每个项目配置文件除了定义ThinkPHP所需要的配置参数之外，开发人员可以在里面添加项目需要的一些配置参数，用于自己的应用。项目配置文件默认存储于项目的Conf目录。
项目配置指的是项目的全局配置，因为一个项目除了可以定义项目配置文件之外，还可以定义模块配置文件用于针对某个特定的模块进行特殊的配置。它们的定义格式都是一致的，区别只是配置文件命名的不同。系统会自动在不同的阶段读取配置文件。


###20.3.2　调试配置
如果启用调试模式，那么会导入框架默认的调试配置文件。默认的调试配置文件位于Think\Common\debug.php，如果没有检测到项目的调试配置文件，就会直接使用默认的调试配置参数。如果项目定义自身的调试配置文件，则会和默认的调试配置文件合并，也就是说，项目配置文件也只需要配置和默认调试配置不同的参数或者新增的参数。

调试配置文件也位于项目配置目录下，文件名是debug.php。通常情况下，调试配置文件中可以进行一些开发模式所需要的配置。例如，配置额外的数据库连接用于调试，开启日志写入便于查找错误信息，开启页面Trace输出更多的调试信息等。

系统默认的调试配置文件中设置如下内容：
* 开启日志记录
* 关闭模板缓存
* 记录SQL日志
* 关闭字段缓存
* 开启运行时间详细显示（包括内存、缓存情况）
* 开启页面Trace信息显示
* 严格检查文件大小写（即使是Windows平台）


##20.4　ThinkPHP的控制器

###20.4.1　控制器
ThinkPHP的控制器就是模块类，通常位于项目的Lib\Action目录下。类名就是模块名加上Action后缀，例如，IndexAction类表示Index模块。控制器类必须继承系统的Action基础类，这样才能确保使用Action类内置的方法。

而index操作其实就是IndexAction类的一个公共方法，所以在浏览器中输入http://localhost/myApp/index.php/Index/index/，其实就是执行IndexAction类的index（公共）方法。

每个模块的操作并非一定要定义操作方法，如果只是希望输出一个模板，既没有变量，也没有任何的业务逻辑，那么只要按照规则定义好操作对应的模板文件即可，而不需要定义操作方法。例如，在IndexAction中如果没有定义help方法，但是存在对应的Index/help.html模板文件，那么http://localhost/TM/sl/20/index.php/Index/help/依然可以正常运作，因为系统找不到IndexAction类的help方法，会自动定位到Index模块的模板目录中查找help.html模板文件，然后直接输出。


###20.4.2　跨模块调用


##20.5　ThinkPHP的模型

###20.5.1　模型的命名
在定义模型时，ThinkPHP要求数据库的表名和模型类的命名遵循一定的规范，首先数据库的表名和字段全部采用小写形式，模型类的命名规则是除去表前缀的数据表名称，并且首字母大写，然后加上模型类的后缀定义。

例如，UserModel表示User数据对象，假设数据库的前缀定义是think_，则其对应的数据表应该是think_user；UserTypeModel对应的数据表是think_user_type。

如果你的规则和系统的约定不符合，那么需要设置Model类的tableName属性。在ThinkPHP的模型里面，有两个数据表名称的定义：tableName

不包含表前后缀的数据表名称，一般情况下默认和模型名称相同，只有当表名和当前模型类的名称不同时才需要定义。例如，在数据库里面有一个think_categories表，而定义的模型类名称是CategoryModel，按照系统的约定，这个模型的名称是Category，对应的数据表名称应该是think_category（全部小写），但是现在的数据表名称是think_categories，因此就需要设置tableName属性来改变默认的规则（假设已经在配置文件里面定义了DB_PREFIX为think_）。
protected $tableName = 'categories';

这个属性的定义不需要加表的前缀think_。
trueTableName

包含前后缀的数据表名称，也就是数据库中的实际表名，该名称无须设置，只有当上面的规则都不适用的情况或者特殊情况下才需要设置。例如，数据库中有一个表（top_depts）的前缀和其他表前缀不同，不是think_而是top_，这个时候需要定义trueTableName属性。
protected $trueTableName = 'top_depts';
trueTableName需要完整的表名定义。

除了数据表的定义外，还可以对数据库进行定义：
dbName定义模型当前对应的数据库名称，只有当前的模型类对应的数据库名称和配置文件不同时才需要定义，例如：
protected $dbName = 'top';


###20.5.2　实例化模型
在ThinkPHP中，无须进行任何模型定义（只有在需要封装单独的业务逻辑的时候，模型类才是必须被定义的），可以直接进行模型的实例化操作。根据不同的模型定义，实例化模型的方法也有所不同，下面来分析一下什么情况下使用什么方法。

1．实例化基础模型（Model）类
在没有定义任何模型的时候，可以使用下面的方法实例化一个模型类来进行操作：
    $User = new Model('User');
    $User->select();         //进行其他的数据操作
或者使用M快捷方法进行实例化，其效果是相同的。
    $User = M('User');
    $User->select();         //进行其他的数据操作
这种方法最简单高效，因为不需要定义任何的模型类，所以支持跨项目调用。缺点也是因为没有自定义的模型类，因此无法写入相关的业务逻辑，只能完成基本的CURD操作。在例20.2和例20.4中采用的都是实例化基础模型类，对数据库中数据进行读取、添加操作。

2．实例化其他模型类
第一种方式实例化因为没有模型类的定义，因此很难封装一些额外的逻辑方法，不过大多数情况下，也许只是需要扩展一些通用的逻辑，那么就可以尝试下面一种方法。
M方法默认是实例化Model类，如果需要实例化其他模型类，可以使用：
    $User = new CommonModel('User','think_','db_config');
由上面的代码可见，模型类的实例化方法有三个参数，第一个参数是模型名称，第二个参数用于设置数据表的前缀（留空则取当前项目配置的表前缀），第三个参数用于设置当前使用的数据库连接信息（留空则取当前项目配置的数据库连接信息）。
第三个连接信息参数可以使用DSN配置或者数组配置，甚至可以支持配置参数。用M方法实现的话，上面的方法可以写成：
    $User = M('CommonModel:User','think_','db_config');
M方法默认是实例化Model类，第二个参数用于指定表前缀，第三个参数就可以指定其他的数据库连接信息。
因为系统的模型类都能够自动加载，因此不需要在实例化之前手动进行类库导入操作。模型类commonModel必须继承Model，如果没有定义别名导入，需要放在项目Model下。可以在CommonModel类里面定义一些通用的逻辑方法，就可以省去为每个数据表定义具体的模型类，如果项目的数据表超过100个，而且大多数都是执行基本的CURD操作，只是个别模型有一些复杂的业务逻辑需要封装，那么第一种方式和第二种方式的结合是一个不错的选择。

3．实例化用户定义的模型（×××Model）类
这种情况是使用得最多的，一个项目不可避免地需要定义自身的业务逻辑实现，就需要针对每个数据表定义一个模型类，例如UserModel、InfoModel等。

定义的模型类通常都是放到项目的Lib\Model目录下。例如：
```
    class UserModel extends Model{
        Public function myfun(){
            //添加自己的业务逻辑
            …
        }
    }
```
其实，模型类还可以继承一个用户自定义的公共模型类，而不是只能继承Model类。要实例化自定义模型类，可以使用下面的方式：
    $User = new UserModel();
    $User->select();                            //进行其他的数据操作
还可以使用D快捷方法进行实例化，其效果是相同的。
    $User = D('User');
    $User->select();                            //进行其他的数据操作
D方法可以自动检测模型类，不存在时系统会抛出异常，同时对于已实例化过的模型，不会重复去实例化。默认的D方法只能支持调用当前项目的模型，如果需要跨项目调用，需要使用：
    $User=D('Admin://User');                   //实例化Admin项目下面的User模型
    $User->select();
如果启用模块分组功能，还可以使用：
    $User=D('Admin/User');                    //实例化Admin分组的User模型

4．实例化空模型类
如果仅仅是使用原生SQL查询，不需要使用额外的模型类，实例化一个空模型类即可进行操作，例如：
    $Model = new Model();
    // 或者使用M快捷方法实例化是等效的
    // $Model = M();
    $Model->query('SELECT ＊ FROM think_user where status=1');
空模型类也支持跨项目调用。


###20.5.3　属性访问
ThinkPHP利用PHP 5的魔术方法机制来实现属性的直接访问。这也是最常用的访问方式，通过数据对象访问，例如：
```
    <?php
      $User = new Model('User');
      $User->find(1);
      echo $User->name;             //获取name属性的值
      $User->name='ThinkPHP';      //设置name属性的值
    ?>
```
还有一种属性的操作方式是通过返回数组的方式，例如：
```
    <?php
      $Type=D('Type');               //注意这里返回的type数据是一个数组
      $type = $Type->find(1);
      echo $type['name'];            //获取type属性的值
      $type['name']='ThinkPHP';      //设置type属性的值
    ?>
```

###20.5.4　连接数据库
ThinkPHP内置抽象数据库访问层，把不同的数据库操作封装起来，只需使用公共的Db类进行操作，而无须针对不同的数据库写不同的操作代码，Db类会自动调用相应的数据库适配器来处理。目前的数据库包括MySQL、MSSQL、PgSQL、SQLite、Oracle、Ibase以及PDO的支持，如果应用需要使用数据库，必须配置数据库连接信息，数据库的配置文件有多种定义方式。

1．在项目配置文件里面定义
在前面的实例中已经见识过了。其代码如下：
```
    <?php
      return array(
        'APP_DEBUG'=>false,            //关闭调试模式
        'DB_TYPE'=>'mysql',            //数据库类型
        'DB_HOST'=>'localhost',        //数据库服务器地址
        'DB_NAME'=>'db_database20',    //数据库名称
        'DB_USER'=>'root',             //数据库用户名
        'DB_PWD'=>'111',               //数据库密码
        'DB_PORT'=>'3306',             //数据库端口
        'DB_PREFIX'=>'think_',         //数据表前缀
      );
    ?>
```
系统推荐使用这种方式，因为一般一个项目的数据库访问配置是相同的。使用该方法，系统在连接数据库的时候会自动获取，无须手动连接。

可以对每个项目定义不同的数据库连接信息，还可以在调试配置文件里面定义调试数据库的配置信息，如果在项目配置文件和调试模式配置文件里面同时定义了数据库连接信息，那么在调试模式下后者生效，部署模式下前者生效。

2．使用DSN方式在初始化Db类的时候传参数
```
    $db_dsn="mysql://root:111@127.0.0.1:3306/db_database20";        //定义DSN
    $db=new Db();                                                   //执行类的实例化
    $conn=$db->getInstance($db_dsn);                                //连接数据库，返回数据库驱动类
```
该方式主要用于在控制器里面自己手动连接数据库的情况，或者用于创建多个数据库连接。

3．在模型类里面定义参数，连接数据库
```
    protected $connection = array(
        'dbms' => 'mysql',
        'username' => 'username',
        'password' => 'password',
        'hostname' => 'localhost',
        'hostport' => '3306',
        'database' => 'dbname'
    );
    //或者使用下面的方式定义
    protected $connection = "mysql://username:password@localhost:3306/DbName";
```
如果在某个模型类里面定义了connection属性，则在实例化模型对象的时候，会使用该数据库连接信息进行数据库连接。通常用于某些数据表位于当前数据库连接之外的其他数据库。

ThinkPHP并不是在一开始就会连接数据库，而是在有数据查询操作的时候才会去连接数据库。额外的情况是，在系统第一次操作模型的时候，框架会自动连接数据库获取相关模型类的数据字段信息，并缓存下来。

4．使用PDO方式连接数据库
这里在项目配置文件中应用PDO连接数据库，其定义的数组内容如下：
```
    return array(
        'DB_TYPE'=> 'pdo',
        //注意DSN的配置针对不同的数据库有所区别
        'DB_DSN'=> 'mysql:host=localhost;dbname=db_database20',
        'DB_USER'=>'root',
        'DB_PWD'=>'111',
        'DB_PREFIX'=>'think_',
        …                          //其他项目配置参数
        'APP_DEBUG'=>false,         //关闭调试模式
    );
```
在使用PDO方式的时候，要注意检查PHP环境是否开启相关的PDO模块。同时还要确保ThinkPHP核心包中包含DbPdo.class.php文件。另外，还要注意参数DB_DSN仅对PDO方式连接才有效。


###20.5.5　创建数据
ThinkPHP可以自动根据表单数据创建数据对象，这个优势在一个数据表的字段非常多的情况下尤其明显。

Create方法在创建数据对象的同时，还实现了一些非常有意义的功能，包括支持多种数据源、数据自动验证、字段类型检查和数据自动完成等。

Create方法创建的数据对象被保存在内存中，并没有实际写入数据库中，直到使用add或者save方法，才真正将数据添加到数据库中。如果只是想简单创建一个数据对象，那么可以使用data方法。

使用data方法创建的数据对象不会进行自动验证和过滤操作，需要自行处理。但在进行add或者save操作的时候，数据表中不存在的字段以及非法的数据类型（例如对象、数组等非标量数据）是会自动过滤的，不用担心非数据表字段的写入导致SQL错误的问题。


###20.5.6　连贯操作
ThinkPHP模型基础类提供的连贯操作方法，可以有效地提高数据存取的代码的清晰度和开发效率。
例如，查询一个User表的满足状态为1的前5条记录，并按照用户的ID排序，其关键代码如下：
`$User->where('status=1')->order('id')->limit(5)->select();`
在连贯操作中，select方法必须放到最后一个，其他的连贯操作方法调用顺序没有先后。如果不习惯使用连贯操作，那么新版还支持直接使用参数进行查询的方式。
例如，上面的代码可以改写为：
`$User->select(array('order'=>'id', 'where'=>'status=1', 'limit'=>'5'));`
如果使用数组参数方式，索引的名称就是连贯操作的方法名称。其实，不仅仅是查询方法可以使用连贯操作，包括add、save、delete等方法都可以使用，例如：
`$User->where('id=1')->field('id,user,address')->find();`
`$User->where('status=1 and id=1')->delete();`


###20.5.7　CURD操作
ThinkPHP提供了灵活和方便的数据操作方法，CURD（创建、更新、读取和删除）是四个最基本的数据库操作。CURD操作通常与连贯操作配合使用。下面将对各种操作的使用方法进行分析（在执行类的实例化操作时，统一使用M方法）。

1．创建操作
在ThinkPHP中使用add方法完成数据的添加操作。其使用方法如下：
```
    $User=M("User");                                       //实例化User对象
    $data['name'] = 'ThinkPHP';
    $data['email'] = 'ThinkPHP@gmail.com';
    $User->add($data);
```
或者使用data方法进行连贯操作。其代码如下：
`$User->data($data)->add();`
如果在add之前已经创建数据对象（例如使用了Create或者data方法），则add方法就不需要再传入数据了。

2．更新数据
第一种，在ThinkPHP中使用save方法更新数据库，并且也支持连贯操作的使用。例如，更新数据表中name和email字段的值。其代码如下：
```
    $User=M("User");                                       //实例化User对象
    $data['name']='ThinkPHP';                              //要修改的数据对象属性赋值
    $data['email'] = 'ThinkPHP@gmail.com';
    $User->where('id=5')->save($data);                     //根据条件保存修改的数据
```
save方法在执行更新数据的操作时，如果没有设置任何更新条件，且数据对象本身也不包含主键字段，那么save方法不会更新任何数据库的记录。

第二种，通过data方法创建要更新的数据对象，然后通过save方法进行保存。例如：
```
    $User=M("User");                                       //实例化User对象
    $data['name']='ThinkPHP';                              //要修改的数据对象属性赋值
    $data['email']='ThinkPHP@gmail.com';                   //要修改的数据对象属性赋值
    $User->where('id=5')->data($data)->save();             //根据条件保存修改的数据
```

第三种，针对某个字段的值，应用setField方法进行更新。例如，更新数据表中字段name的值，条件是ID为5的记录。
```
    $User=M("User");                                       //实例化User对象
    $User->where('id=5')->setField('name','ThinkPHP');     //更改用户的name值
```

如果要更新多个字段的值，也可以应用setField方法，只需要传入数组即可，例如：
```
    $User=M("User");                                       //实例化User对象
    //更改用户的name和email的值
    $User-> where('id=5')->setField(array('name','email'),array('ThinkPHP','ThinkPHP@gmail.com'));
```

第四种，应用setInc和setDec方法对统计字段（通常指的是数字类型）中的值进行增减操作。例如，对指定用户的积分进行增、减操作。
```
    $User=M("User");                                                 //实例化User对象
    $User->setInc('score','id=5',3);                                 //用户的积分加3
    $User->setInc('score','id=5');                                   //用户的积分加1
    $User->setDec('score','id=5',5);                                 //用户的积分减5
    $User->setDec('score','id=5');                                   //用户的积分减1
```

3．读取数据
在ThinkPHP中读取数据的方式很多，通常分为读取某个字段的值、读取数据和读取数据集。读取字段的值使用getField方法，读取数据使用find方法，读取数据集使用select方法。

getField方法读取某个字段的值，如果传入多个字段，可以返回一个关联数组。返回的list是一个数组，键名是用户的id，键值是用户的昵称nickname。例如，获取ID为3的用户的昵称，获取所有用户的ID和昵称列表。
```
    $User=M("User");                                              //实例化User对象
    $nickname=$User->where('id=3')->getField('nickname');         //获取ID为3的用户的昵称
    $list=$User->getField('id,nickname');                         //获取所有用户的ID和昵称列表
```
select方法的返回值是一个二维数组，如果没有查询到任何结果，也是返回一个空的数组。配合上面提到的连贯操作方法可以完成复杂的数据查询。例如，查找status值为1的用户数据以创建时间排序返回10条数据。
```
    $User=M("User");                                            //实例化User对象
    $list = $User->where('status=1')->order('create_time')->limit(10)->select();
```

find方法与select方法类似，select方法可用的所有连贯操作方法也都可以用于find方法，区别在于find方法最多只会返回一条记录，因此limit方法对于find方法查询操作是无效的。例如，查找status值为1，name值为think的用户数据。
```
    $User=M("User");                                            //实例化User对象
    $User->where('status=1 and name="think" ')->find();
```

即使满足条件的数据不止一条，find方法也只会返回第一条记录。

4．删除数据
在ThinkPHP中使用delete方法删除数据库中的记录。同样可以使用连贯操作进行删除操作。例如，删除数据表中ID为5的记录。
```
    $User=M("User");                             //实例化User对象
    $User->where('id=5')->delete();              //删除ID为5的用户数据
```
delete方法可以用于删除单个或者多个数据，主要取决于删除条件，也就是where方法的参数，也可以用order和limit方法来限制要删除的个数。例如，删除所有状态为0的5个用户数据按照创建时间排序。
```
    $User=M("User");                         //实例化User对象
    $User->where('status=0')->order('create_time')->limit('5')->delete();
```

##20.6　ThinkPHP的视图
在ThinkPHP中，视图由两个部分组成：View类和模板文件。Action控制器直接与View视图类进行交互，把要输出的数据通过模板变量赋值的方式传递到视图类，而具体的输出工作则交由View视图类来进行，同时视图类还完成了一些辅助的工作，包括调用模板引擎、布局渲染、输出替换、页面Trace等功能。为了方便使用，在Action类中封装了View类的一些输出方法，例如display、fetch、assign、trace和buildHtml等方法，这些方法的原型都在View视图类中。

###20.6.1　模板定义
为了对模板文件进行更有效的管理，ThinkPHP对模板文件进行目录划分，默认的模板文件定义规则是：
`模板目录/[分组名/][模板主题/]模块名/操作名+模板后缀`
模板目录默认是项目下的Tpl，在定义分组的情况下，会按照分组名分开子目录，新版模板主题默认是空（表示不启用模板主题功能）。模板主题功能是为了多模板切换而设计的，如果有多个模板主题，则可以使用DEFAULT_THEME参数设置默认的模板主题名。

在每个模板主题下，是以项目的模块名为目录，然后是每个模块的具体操作模板文件。例如，User模块的add操作对应的模板文件是Tpl/User/add.html。

模板文件的默认后缀是.html，后缀可以通过TMPL_TEMPLATE_SUFFIX来配置。

如果项目启用模块分组功能（假设User模块属于Home分组），那么默认对应的模板文件就会发生变化，Tpl/Home/User/add.html。

分组功能可以通过TMPL_FILE_DEPR参数来配置，进而简化模板的目录层次。例如，设置TMPL_FILE_DEPR等于“_”，那么默认的模板文件就变成Tpl/Home/User_add.html。

正是因为系统有了这样一种模板文件自动识别的规则，display方法才可以无须带任何参数就输出对应的模板。

20.6.2　模板赋值
模板赋值是在Action控制器中完成的，通过assign方法将控制器中获取的数据赋给模板变量。例如：
`$this->assign('name',$value);

如果要同时输出多个模板变量，可以使用数组的方式进行赋值。
```
    $array = array();
    $array['name'] = 'thinkphp';
    $array['email'] = 'liu21st@gmail.com';
    $array['phone'] = '12335678';
    $this->assign($array);
```
这样，就可以在模板文件中同时输出name、email和phone这3个变量。

20.6.3　指定模板文件
模板变量赋值后就需要调用模板文件来输出相关的变量，模板调用应用的是display方法。

模板变量赋值后就需要调用模板文件来输出相关的变量,模板调用通过display方法来实现,我们在操作方法的最后使用:
代码如下:
$this->display();
就可以输出模板,根据前面的模板定义规则,因为系统会按照默认规则自动定位模板文件,所以通常display方法无需带任何参数即可输出对应的模板,这是模板输出的最简单的用法。
事情总有特例,或者根本不需要按模块进行分目录存放,不过display方法总是能够帮你解决问题。
Display方法提供了几种规则让你可以随心所欲的输出需要的模板,无论你的模板文件在什么位置。
下面来看具体的用法:

一、调用当前模块的其他操作模板
格式:display('操作名')
例如,假设当前操作是User模块下面的read操作,我们需要调用User模块的edit操作模版,使用：
代码如下:
$this->display('edit');
不需要写模板文件的路径和后缀。

二、调用其他模块的操作模板
格式：display('模块名:操作名')
例如，当前是User模块，我们需要调用Member模块的read操作模版 ，使用：
代码如下:
$this->display('Member:read');
这种方式也不需要写模板文件的路径和后缀，严格来说，这里面的模块名和操作名并不一定需要有对应的模块或者操作，只是一个目录名称和文件名称而已，例如，你的项目里面可能根本没有Public模块，更没有Public模块的menu操作，但是一样可以使用
代码如下:
$this->display('Public:menu');
输出这个模板文件,理解了这个,模板输出就清晰了.

三、调用其他主题的操作模板
格式：display('主题名:模块名:操作名')
例如我们需要 调用Xp主题的User模块的edit操作模版，使用：
代码如下:
$this->display('Xp:User:edit');
这种方式需要指定模块和操作名

四、直接全路径输出模板
格式：display('模板文件名')
例如，我们直接输出当前的Public目录下面的menu.html模板文件，使用： 
代码如下:
$this->display('./Public/menu.html');
这种方式需要指定模板路径和后缀,这里的Public目录是位于当前项目入口文件位置下面,如果是其他的后缀文件,也支持直接输出,例如：
代码如下:
$this->display('./Public/menu.tpl');
只要./Public/menu.tpl是一个实际存在的模板文件,如果使用的是相对路径的话,要注意当前位置是相对于项目的入口文件,而不是模板目录.
事实上,display方法还有其他的参数和用法。
有时候某个模板页面我们需要输出指定的编码,而不是默认的编码,可以使用：
代码如下:
$this->display('Member:read', 'gbk');
或者输出的模板文件不是text/html格式的,而是XML格式的,可以用：
代码如下:
$this->display('Member:read', 'utf-8', 'text/xml');
如果你的网站输出编码不是默认的编码,可以使用:
代码如下:
'DEFAULT_CHARSET'=> 'gbk'
如果要输出XML格式的，可以用：
代码如下:
'TMPL_CONTENT_TYPE'=> 'text/xml'
如果不需要渲染模板文件而是直接输出内容,可以使用show方法,例如：
代码如下:
$this->show($content, 'utf-8', 'text/xml');
希望本文所述对大家的ThinkPHP框架程序设计有所帮助。


###20.6.4　特殊字符串替换
在进行模板输出之前，系统还会对模板的特殊字符串进行替换，实现模板输出的替换和过滤。这个机制可以使得模板文件的定义更加方便，默认的替换规则如表

特殊字符串|替换描述
---|---
../Public|被替换成当前项目的公共模板目录，通常是：/项目目录/Tpl/当前主题/Public/
__PUBLIC__|被替换成当前网站的公共目录，通常是：/Public/
__TMPL__|替换成项目的模板目录，通常是：/项目目录/Tpl/当前主题
__ROOT__|会被替换成当前网站的地址
__APP__|替换成当前项目的URL地址
__URL__|替换成当前模块的URL地址
__ACTION__|替换成当前操作的URL地址
__SELF__|替换成当前的页面URL

这些特殊的字符串是严格区别大小写的，并且这些特殊字符串的替换规则是可以更改或者增加的。只要在项目配置文件中配置TMPL_PARSE_STRING就可以完成。如果有相同的数组索引，就会更改系统的默认规则。例如：
```
      TMPL_PARSE_STRING  =>array(
              '__PUBLIC__'=>'/Common',              //更改默认的__PUBLIC__替换规则
              '__UPLOAD__'=>'/Public/Uploads/',     //增加新的上传路径替换规则
      )
```

##20.7　内置ThinkTemplate模板引擎
ThinkPHP内置了一个基于XML的性能卓越的模板引擎ThinkTemplate，这是一个专门为ThinkPHP服务的内置模板引擎。ThinkTemplate是一个使用XML标签库技术编的模板引擎，支持两种类型的模板标签（普通标签和XML标签），使用了动态编译和缓存技术，而且支持自定义标签库。

ThinkTemplate模板引擎生成的编译文件默认存储于Runtime\Cache目录下，以模板文件的md5编码作为缓存文件名保存。

ThinkTemplate模板引擎中的常用标签

普遍变量输出

num1:{$num1}

对象输出

id:{$obj:id}

name:{$obj:name}

数组输出

id:{$vo['id']}

name:{$vo['name']}

自动判断数组和对象输出

id:{$vo.id}

name:{$vo.name}

系统常量输出（系统常量可以不用在控制器中使用 assign 赋值）

{$Think.now|date='Y-m-d H:i:s',###}

{$Think.server.PHP_SELF}

{$Think.session.name}

对变量使用函数(这里可以是内置函数或者自定义函数)

{$vo.name|strtolower|ucwords}

Foreach 输出

<foreach name="vo" key="key" item="item">
{$key}:{$item}
</foreach>

下面这个例子使用了循环标签、Switch标签、比较标签

<volist name="array" id="val" key="i">
[{$i}]
<eq name="odd" value="1">偶数行</eq>
<eq name="odd" value="0">奇数行</eq>
<gt name="val" value="5">{$val}大于5</gt>
<if condition=" $val gt 15"> 
{$val}大于15
<elseif condition="$val lt 10" />
{$val}小于10
</if>
<switch name="val">
<case value="1">数据{$val}</case>
<case value="2">数据{$val}</case>
<case value="3">数据{$val}</case>
<default />其他数据是 {$val}
</switch>
</volist>

输出结果类似为：

[1] 奇数行 5小于10 长度为1
[2] 偶数行 260大于5 260大于15 长度为3
[3] 奇数行 13大于5 长度为2
[4] 偶数行 7大于5 7小于10 长度为1
[5] 奇数行 40大于5 40大于15 长度为2
[6] 偶数行 50大于5 50大于15 长度为2
[7] 奇数行 2小于10 长度为1
[8] 偶数行 1小于10 长度为1

ThinkPHP内置的模板引擎比较标签

<gt name="num1" value="3">大于3</gt>
<lt name="num2" value="3">小于3</lt>

输出结果类似为：

大于3
小于3
条件判断

<if condition=" $num gt 5">
{$num}大于5
<elseif condition="$num gt 3" />
{$num}大于3<else />
其他{$num}
</if>

输出结果类似为：

6大于5


##20.8　小结


##20.9　实践与练习



---

#第21章 Smarty模板技术

##21.1　Smarty简介
Smarty是PHP中的一个模板引擎，是众多PHP模板中最优秀、最著名的模板之一。

###21.1.2　Smarty与MVC
Smarty这种开发模式，正是基于MVC（Model-View-Controller）框架概念。
MVC，即模型-视图-控制器，是指一个应用程序由3部分构成：模型部分、视图部分和控制部分。
* 模型：对接收的信息进行处理，并将处理结果回传给视图。例如，如果用户输入信息正确，那么将给视图一个命令，允许用户进入主页面，反之则拒绝用户的操作。
* 视图：即提供给用户的界面。视图只提供信息的收集及显示，不涉及处理。如用户登录界面，也就是视图，只提供用户登录的用户名和密码输入框（也可以有验证码、安全问题等信息），至于用户名和密码的对与错，这里不去处理，直接传给后面的控制部分。
* 控制：负责处理视图和模型的对应关系，并将视图收集的信息传递给对应的模型。例如，当用户输入用户名和密码后提交，这时，控制部分接收用户的提交信息，并判断这是一个登录操作，随后将提交信息转发给登录模块部分，也就是模型。


###21.1.3　Smarty的特点
* 采用Smarty模板编写的程序可以获得最快的速度。注意，这是相对于其他模板而言。
* 可以自行设置模板定界符，如{}、{{}}、<!--{}-->等。
* 仅对修改过的模板文件进行重新编译。
* 模板中可以使用if/elseif/else/endif。
* 内建缓存支持。
* 可自定义插件。


##21.2　Smarty的安装配置

###21.2.1　Smarty的下载和安装
PHP没有内置Smarty模板类，需要单独下载和配置，而且Smarty要求服务器上的PHP版本最低为4.0.6。用户可以通过访问http://smarty.php.net/download.php下载最新的Smarty压缩包。本章使用的版本是Smarty-2.6.19。

将压缩包解压后，得到一个libs目录，其中包含了Smarty类库的核心文件，即smarty.class.php、smarty_Compiler.class.php、config_File.class.php和debug.html 4个文件，另外还有internals和plug-ins两个目录。复制libs目录到服务器根目录下，并为其重命名，一般该目录的名称为smarty或class等，这里改为smarty。至此，Smarty模板安装完毕。


###21.2.2　第一个Smarty程序
（1）新建一个程序目录，存放位置为“服务器地址/tm/sl/21/”，命名为1，表示为第一个实例。
（2）复制Smarty到目录1下，在Smarty目录下新建4个目录，分别是templates、templates_c、configs和cache。
（3）新建一个HTML静态页，输入数据。输入完毕后将文件保存到新建的templates目录下，并命名为index.html，实例代码如下：
```
    <html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
        <title>{$title}</title>
      </head>
      <body>
        {$content}
      </body>
    </html>
```
4）回到上级目录，在目录1下新建一个.php文件，使用Smarty变量和方法对文件进行操作，输入完毕后保存为index.php，实例代码如下：
```
    <?php
      /＊  定义服务器的绝对路径  ＊/
      define('BASE_PATH',$_SERVER['DOCUMENT_ROOT']);
      /＊  定义Smarty目录的绝对路径  ＊/
      define('SMARTY_PATH','\TM\sl\21\1\Smarty\\');
      /＊  加载Smarty类库文件    ＊/
      require BASE_PATH.SMARTY_PATH.'Smarty.class.php';
      /＊  实例化一个Smarty对象  ＊/
      $smarty = new Smarty;
      /＊  定义各个目录的路径    ＊/
      $smarty->template_dir = BASE_PATH.SMARTY_PATH.'templates/';
      $smarty->compile_dir = BASE_PATH.SMARTY_PATH.'templates_c/';
      $smarty->config_dir = BASE_PATH.SMARTY_PATH.'configs/';
      $smarty->cache_dir = BASE_PATH.SMARTY_PATH.'cache/';

      /＊  使用Smarty赋值方法将一对名称/方法发送到模板中  ＊/
      $smarty->assign('title','第一个Smarty程序');
      $smarty->assign('content','Hello,Welcome to study \'Smarty\'!');
      /＊  显示模板  ＊/
      $smarty->display('index.html');
    ?>
```
这一步是Smarty运行最关键的步骤，主要进行了两项设置和两步操作。
* 加载Smarty类库：也就是加载Smarty.class.php文件，这里使用的是绝对地址。为了稍后在配置其他路径时不用输入那么长的地址字串，之前还声明了两个常量：服务器地址常量和Smarty路径常量，两个常量连接起来就是Smarty类库所在的目录。
* 保存新建的4个目录的绝对路径到各自的变量：在例21.1中的第（2）步曾创建了4个目录，这4个目录各有各的用途，如果没有配置目录的地址，那么服务器默认的路径就是当前执行文件所在的路径。除了上面两项必须设置的变量外，还可以改变很多Smarty参数值，如开启/关闭缓存、改变Smarty的默认定界符等，这些变量将在21.4.2节中介绍。
* 给模板赋值：设置成功后，需要给指定的模板赋值。assign就是赋值方法。
* 显示模板：一切操作结束后，调用display方法来显示页面。实际上，用户真正看到的页面是templates模板目录下的index.html模板文件，而作为首页的index.php，只是用来传递结果和显示模板。


###21.2.3　Smarty配置
下面详细讲解Smarty模板的配置步骤。
（1）确定Smarty目录的位置。因为Smarty类库是通用的，每一个项目都可能会使用到它，所以将Smarty存储在根目录下。
（2）新建4个目录templates、templates_c、configs和cache。其中目录templates存储项目的模板文件，该目录具体放置在什么位置没有严格的规定，只要设置的路径正确即可；目录templates_c存储项目的编译文件；目录configs存储项目的配置文件；目录cache存储项目的缓存文件。
（3）创建配置文件。如果要应用Smarty模板，就一定要包含Smarty类库和相关信息。将配置信息写到一个文件中，使用时只要include配置文件即可。




























